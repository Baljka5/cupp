{% extends "base.html" %}
{% load event_tags %}
{% load widget_tweaks %}

{% block header %}
{% endblock %}

{% block content %}
    <div class="content">
        <div class="dropdown-section">
            <div class="dropdown-container">
                <label for="year-select">YEAR</label>
                <select id="year-select" name="year">
                    <option value="2023">2023</option>
                    <option value="2024">2024</option>
                    <!-- Additional years as needed -->
                </select>
            </div>
            <div class="dropdown-container">
                <label for="month-select">MONTH</label>
                <select id="month-select" name="month">
                    <option value="jan">JAN</option>
                    <option value="feb">FEB</option>
                    <option value="mar">MAR</option>
                    <!-- Additional months as needed -->
                </select>
            </div>
        </div>

        <div class="teams-container">
            <div class="team-row">
                {% for area in areas %}
                    <div class="team">
                        <div class="team-header">{{ area.team_no }}</div>
                        <div class="team-body" id="area-{{ area.id }}" ondrop="drop(event)"
                             ondragover="allowDrop(event)"
                             data-area-id="{{ area.id }}">

                            {#                        <div class="team-body" ondrop="drop(event)" ondragover="allowDrop(event)"#}
                            {#                             data-area-id="{{ area.id }}">#}
                        </div>
                    </div>
                {% endfor %}
            </div>
            {#            <div class="not-allocated-body" ondrop="drop(event)" ondragover="allowDrop(event)"#}
            {#                 data-area-id="not-allocated">#}
            <div class="not-allocated-body" id="not-allocated" ondrop="drop(event)" ondragover="allowDrop(event)"
                 data-area-id="not-allocated">

                <div class="not-allocated">
                    {% for consultant in consultants %}
                        <div class="sc" id="sc{{ consultant.id }}" draggable="true" ondragstart="drag(event)"
                             data-consultant-id="{{ consultant.id }}">
                            {{ consultant.sc_name }}
                        </div>
                    {% endfor %}
                </div>
            </div>
            <div class="save-close-container">
                {#                <button id="saveCloseBtn">SAVE & CLOSE</button>#}
                <button id="saveCloseBtn" onclick="saveAllocations()">SAVE & CLOSE</button>
            </div>
        </div>
    </div>
    <style>
        .teams-container {
            display: flex;
            flex-direction: column;
            margin: 0 20px;
        }

        .team-row {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        .team {
            background-color: #D1D0CF;
            padding: 10px;
            margin-bottom: 20px;
            flex: 1;
            margin-left: 20px;
        }

        .team:first-child {
            margin-left: 0;
        }

        .team-body {
            background-color: #F4E2D0;
            padding: 10px;
            margin: 5px;
        }

        .team-header {
            font-weight: bold;
            margin-bottom: 10px;
        }

        .sc {
            background-color: #ffcc99;
            padding: 5px;
            margin: 5px 5px;

        }

        .not-allocated-body {
            background-color: #D1D0CF;
            padding: 10px;
            margin: 5px;
        }

        .not-allocated {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }

        .save-close-container {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }

        #saveCloseBtn {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }

        .dropdown-section {
            display: flex;
            justify-content: start;
            margin-bottom: 20px; /* Adjust as needed */
        }

        .dropdown-container {
            margin-right: 20px; /* Adjust space between dropdowns as needed */
        }

        .dropdown-container select {
            display: block;
            width: 100%; /* Adjust width as needed */
            padding: 5px;
            margin-top: 5px; /* Adjust as needed */
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f8f8f8;
        }

        .dropdown-container label {
            display: block;
            text-align: center;
            background-color: #666; /* Adjust color as needed */
            color: white;
            padding: 5px;
            border-radius: 4px;
            margin-bottom: 5px;
        }

    </style>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Fetch and render the current allocations after the page has fully loaded
            fetchAllocationsAndRender();
        });

        function fetchAllocationsAndRender() {
            // Fetch the current allocations from the server
            fetch('/get-allocations/')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    // Use the fetched data to position consultant elements according to their allocations
                    data.forEach(allocation => {
                        // Assuming your consultant elements have IDs formatted as 'sc<consultant_id>'
                        const consultantElement = document.getElementById(`sc${allocation.consultant__id}`);
                        // And your area elements can be identified with a data attribute 'data-area-id'
                        const areaElement = document.querySelector(`[data-area-id="${allocation.area__id}"]`);

                        if (consultantElement && areaElement) {
                            // Move the consultant element to its allocated area
                            const targetContainer = areaElement.querySelector('.team-body') || areaElement;
                            targetContainer.appendChild(consultantElement);
                        }
                    });
                })
                .catch(error => {
                    // Handle any errors that occurred during the fetch
                    console.error('Error fetching allocations:', error);
                });
        }

        function allowDrop(event) {
            event.preventDefault();
        }

        function drag(event) {
            event.dataTransfer.setData("text", event.target.id);
        }

        function drop(event) {
            event.preventDefault();
            var data = event.dataTransfer.getData("text");
            var consultantElement = document.getElementById(data);
            var target = event.target;

            // Ensure we're dropping the consultant into a valid area or back to the not-allocated container
            var targetIsTeamBody = target.classList.contains('team-body');
            var targetIsNotAllocated = target.classList.contains('not-allocated') || target.id === 'not-allocated';

            if (targetIsTeamBody || targetIsNotAllocated) {
                target.appendChild(consultantElement);
            } else {
                // If dropped on a child, find the closest .team-body or .not-allocated container
                var closestTarget = target.closest('.team-body, .not-allocated');
                if (closestTarget) {
                    closestTarget.appendChild(consultantElement);
                }
            }

            // Call function to save updated allocation to the server here
            // saveAllocation(consultantId, targetAreaId);
        }

        // Implement the saveAllocation function to send the updated allocation to the server
        // This function should be implemented based on how your backend expects to receive and process these updates
        function saveAllocations() {
            const allocations = []; // Prepare to collect allocations data

            // Example: Loop through all allocated consultants and prepare data for sending
            document.querySelectorAll('.team-body').forEach(area => {
                const areaId = area.getAttribute('data-area-id');
                area.querySelectorAll('.sc').forEach(consultant => {
                    const consultantId = consultant.getAttribute('data-consultant-id');
                    allocations.push({consultantId, areaId});
                });
            });

            // Send the allocations data to the server using fetch API
            fetch('/save-allocations/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    // Include CSRF token as needed, depending on your server-side setup
                    'X-CSRFToken': getCookie('csrftoken'), // Implement getCSRFToken() to retrieve CSRF token
                },
                body: JSON.stringify({allocations})
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok.');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Success:', data);
                    // Handle success - e.g., show a success message
                })
                .catch((error) => {
                    console.error('Error:', error);
                    // Handle error - e.g., show an error message
                });
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

    </script>


{% endblock %}
